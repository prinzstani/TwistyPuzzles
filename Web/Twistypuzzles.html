<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="three.min.js"></script>

    <title>Twisty Puzzles</title>
</head>
<body>
<div><canvas id="puzzle1"></canvas>
<canvas id="puzzle2"></canvas>
<canvas id="puzzle3"></canvas>
<canvas id="puzzle4"></canvas>
<canvas id="puzzle5"></canvas>
</div>
<div>
<canvas id="puzzle6"></canvas>
<button id="button1">Quick Solve</button>
<button id="button2">Super Solve</button>
<button id="button3">Scramble</button>
</div>
<div id="threeoutput"></div>
<div>
<canvas id="puzzle7"></canvas>
<canvas id="puzzle8"></canvas>
<canvas id="puzzle9"></canvas>
<canvas id="puzzle10"></canvas>
<canvas id="puzzle11"></canvas>
</div>
<div><textarea id="textout"></textarea></div>
</body>

<script>
    // once everything is loaded, we run our Three.js stuff.
    function init() {
        // create a scene, that will hold all our elements such as objects, cameras and lights.
        let scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xffffff );
        // create a camera, which defines where we're looking at.
        let camera = new THREE.PerspectiveCamera(45, 200 / 200, 0.1, 1000);
        // create a render and set the size
        let renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        renderer.setSize(200, 200);
        renderer.shadowMapEnabled = false;
        // create a cube
        let cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
        let cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});

        let geometry = new THREE.BoxGeometry( 4, 4, 4 );
        for ( let i = 0; i < geometry.faces.length; i ++ ) {
            geometry.faces[ i ].color.set("black");
        }
        // The cube should have roughly 12 faces
        geometry.faces[0].color.set("red");
        geometry.faces[1].color.set("red");
        geometry.faces[4].color.set("blue");
        geometry.faces[5].color.set("blue");
        geometry.faces[8].color.set("yellow");
        geometry.faces[9].color.set("yellow");



        let material = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: true } );

        let cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true;
        // position the cube
        cube.position.x = 0;
        cube.position.y = 0;
        cube.position.z = 0;

        //add wireframe
        let wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } );

        let wireframe = new THREE.Mesh( geometry, wireframeMaterial );
        cube.add( wireframe );

        // add the cube to the scene
        scene.add(cube);
        // position and point the camera to the center of the scene
        camera.position.x = -30;
        camera.position.y = 40;
        camera.position.z = 30;
        camera.lookAt(scene.position);
        // add subtle ambient lighting
        var ambientLight = new THREE.AmbientLight(0xffffff);
        scene.add(ambientLight);
        // add spotlight for the shadows
        /*var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-40, 60, -10);
        spotLight.castShadow = true;
        scene.add(spotLight);*/
        // add the output of the renderer to the html element
        document.getElementById("threeoutput").appendChild(renderer.domElement);
        // call the render function
        var step = 0;
        renderScene();
        function renderScene() {
            // rotate the cube around its axes
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.02;
            // render using requestAnimationFrame
            requestAnimationFrame(renderScene);
            renderer.render(scene, camera);
        }
    }
    window.onload = init;
</script>
</html>